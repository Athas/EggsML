#!/usr/bin/env perl
use 5.020;
use strict;
use warnings;

use Cwd;
use IO::All;
use File::Spec;
use Git::Repository qw(Blame Log);
use Time::Piece;
use IPC::System::Simple qw(capturex);

use Env qw(EGGS_USER CONCIEGGS_DIR CONCIEGGS_NAME);
use EggsML::EggsPI boolean => [qw(annoyedBy)],
                   list => [qw(recentlyActive)],
                   text => [qw(writtenIn findCommand)];

my $arg = shift @ARGV;
if (!$arg) {
    say "Brug: ansvar <fil | /regex/i>";
    exit;
}

sub victim {
    my @victims = recentlyActive;
    return $victims[rand @victims];
}

my $repo = Git::Repository->new;

if (my ($regex, $i) = $arg =~ qr{^/(.*?)/(i?)$}) {
    my @matches = capturex('ackgrep', '--ignore-dir=db', ($i ? '-i' : ()), '--', $regex);
    if (!@matches) {
        my $victim = victim;
        say "$EGGS_USER: Den stump kode har jeg aldrig set før, men det var sikkert $victim som gjorde det!";
        exit;
    }

    my $n = @matches;
    if ($n > 5) {
        say "$EGGS_USER: Den stump kode forekommer godt nok mange gange ($n).  " .
            "  Det er næppe originalt nok til at give nogen ansvar for.";
        exit;
    }

    for my $match (@matches) {
        my ($match_filename, $match_line, $match_text) = split /:/, $match, 3;
        my $git_match_filename = File::Spec->catfile($CONCIEGGS_DIR, $match_filename);
        my $blame = $repo->blame($git_match_filename, ignore_whitespace => 0);
        my $author = $blame->[$match_line]->{commit_attributes}->{author};

        $match_text =~ s/^\s*//;
        $match_text =~ s/\s*$//;
        say "Linje $match_line i $match_filename er skrevet af $author: $match_text";
    }

    exit;
}

my $cwd_filename = $arg =~ qr{/} ? $arg : findCommand($arg);

my $git_filename =
    $cwd_filename =~ qr{^/}
        ? $cwd_filename
        : File::Spec->catfile($CONCIEGGS_DIR, $cwd_filename);

unless (($git_filename // '') =~ /^\Q$CONCIEGGS_DIR\E/) {
    say "$EGGS_USER: Glem det.";
    annoyedBy($EGGS_USER, 10, "bad mig om at finde ansvar udenfor concieggs-mappen");
    exit;
}

if (! -f $cwd_filename) {
    my $victim = victim;
    say "$EGGS_USER: Jeg er ikke bekendt med noget $cwd_filename-programmel." .
        "  Måske du skulle bede $victim om at lave det?";
    exit;
}

if ($cwd_filename eq $CONCIEGGS_NAME) {
    say "$EGGS_USER: Nøj, hvor er du sjov!";
    annoyedBy($EGGS_USER, 1, "spurgte hvem der har ansvar for mig");
    exit;
}

my @lines = io($cwd_filename)->slurp;
my $lang = writtenIn($cwd_filename);

my $log = [ $repo->log(qw(--follow), $git_filename) ];
my $blame = $repo->blame($git_filename, ignore_whitespace => 0);

my $n_commits = @$log;
my $creator = $log->[-1]->{author_name};
my $created = $log->[-1]->{author_gmtime};
my $created_commit_id = $log->[-1]->{commit};

my %authors;
my %commits;
my $total_lines = 0;

my $oldest_commit = $blame->[0]->{commit_attributes};
my $newest_commit = $oldest_commit;

my $i = 0;
for my $line (@$blame) {
    # Pretend whitespace lines don't exist.
    next if $lines[$i++] =~ /^\s*$/;

    my $commit_id = $line->{commit_id};
    $commits{$commit_id}++;

    my $commit = $line->{commit_attributes};
    my $author = $commit->{author};
    $authors{$author}++;
    $total_lines++;

    $oldest_commit = $commit if $commit->{'author-time'} < $oldest_commit->{'author-time'};
    $newest_commit = $commit if $commit->{'author-time'} > $newest_commit->{'author-time'};
}

sub og {
    my $last = pop;
    my $first = join ", ", @_;
    return "$first og $last";
}

my $created_commit_time = localtime($created)->strftime('%Y-%m-%d %H:%M');
my $oldest_commit_time = localtime($oldest_commit->{'author-time'})->strftime('%Y-%m-%d %H:%M');
my $newest_commit_time = localtime($newest_commit->{'author-time'})->strftime('%Y-%m-%d %H:%M');
my $newest_commit_summary = (split /\n/, $newest_commit->{summary})[0];

my $output = "Filen blev skabt af $creator $created_commit_time";

# Solo-projekt
if (keys %authors == 1) {
    my $author = (keys %authors)[0];
    if ($creator ne $author) {
        $output .= ", sidenhen omskrevet af $author i $lang,";
    } else {
        $output .= ", er kodet i $lang,";
    }

    $output .= sprintf(" og de%s %d linje%s kode er lavet over en serie af %d commits.",
                       $total_lines == 1 ? 'n' : '',
                       $total_lines,
                       $total_lines == 1 ? '' : 'r',
                       $n_commits);

    if ($n_commits > 1) {
        $output .= sprintf("  Den seneste ændring blev indført %s med beskeden: %s",
                           $newest_commit_time,
                           $newest_commit_summary);
    }

# Samarbejde
} else {
    my $authors =
        og(map { sprintf("%s (%.2f%%, %d linje%s)",
                         $_,
                         ($authors{$_} / $total_lines * 100),
                         $authors{$_},
                         $authors{$_} == 1 ? '' : 'r');
               } keys %authors);

    if ($commits{$created_commit_id}) {
        $output .= sprintf(" og indeholder stadig %d linje%s original $lang-kode.",
                           $commits{$created_commit_id},
                           $commits{$created_commit_id} == 1 ? '' : 'r');
    } elsif ($lang) {
        $output .= ", men er sidenhen blevet omskrevet i $lang.";
    } else {
        $output .= ", men indeholder ikke længere original kode.";
    }

    $output .= "  Den indeholder ændringer af $authors via $n_commits commits.";
    $output .= sprintf("  Den seneste ændring blev indført af %s %s med beskeden: %s",
                       $newest_commit->{author},
                       $newest_commit_time,
                       $newest_commit_summary);
}
say $output;
