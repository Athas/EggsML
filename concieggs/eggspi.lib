# Shell script function definitions

decomment() {
    sed 's/ *#.*//' 
}

randomise() {
    sort -R --random-source=/dev/urandom
}

docstring() {
    awk 'BEGIN{indoc=1}\
/^#!/{next}\
/^[^#]/{indoc=0}\
/^# ?$/{next}\
indoc{out = out substr($0, 3, length($0)) " "}\
END{print out}'
}

commasize() {
    awk '{if (out && last) { out = out ", " last; last = $0 }\
else if (out) { last = $0 }\
else { out = $0 } }\
END{ if (last) { if (out) { out = out ", " last } else { out = last } };\
print out }'
}

enumerate() {
    awk '{if (out && last) { out = out ", " last; last = $0 }\
else if (out) { last = $0 }\
else { out = $0 } }\
END{ if (last) { if (out) { out = out " og " last } else { out = last } };\
print out }'
}

ack() {
    (echo "Aj-aj";
        echo "Javel";
        echo "OK";
        echo "Forstået";
        echo "Accepteret";
        echo "Det er i orden";
        echo "Roger") \
            | randomise | head -n 1 | xargs echo -n
    (echo "!"; echo ".") | randomise | head -n 1
}

levenshtein() {
prog=$(cat <<EOF
function levdist(str1, str2, l1, l2, tog, arr, i, j, a, b, c) {
  if (str1 == str2) {
    return 0
  } else if (str1 == "" || str2 == "") {
    return length(str1 str2)
  } else if (substr(str1, 1, 1) == substr(str2, 1, 1)) {
    a = 2
    while (substr(str1, a, 1) == substr(str2, a, 1)) a++
    return levdist(substr(str1, a), substr(str2, a))
  } else if (substr(str1, l1=length(str1), 1) == substr(str2, l2=length(str2), 1)) {
    b = 1
    while (substr(str1, l1-b, 1) == substr(str2, l2-b, 1)) b++
    return levdist(substr(str1, 1, l1-b), substr(str2, 1, l2-b))
  }
  for (i = 0; i <= l2; i++) arr[0, i] = i
  for (i = 1; i <= l1; i++) {
    arr[tog = ! tog, 0] = i
    for (j = 1; j <= l2; j++) {
      a = arr[! tog, j  ] + 1
      b = arr[  tog, j-1] + 1
      c = arr[! tog, j-1] + (substr(str1, i, 1) != substr(str2, j, 1))
      arr[tog, j] = (((a<=b)&&(a<=c)) ? a : ((b<=a)&&(b<=c)) ? b : c)
    }
  }
  return arr[tog, j-1]
}
{ print levdist(\$0,FROM), \$0 }
EOF
)
awk -v "FROM=$1" "$prog"
}

eggstool() {
    $EGGS_LIB_DIR/eggstool.py $EGGS_DIR/slashdotfrokost "$@"
}

aliases() {
    eggstool aliases "$1"
}

randomName() {
    aliases "$1" | randomise | head -n 1
}

cmpNames() {
    eggstool cmpnames "$1" "$2"
}

dateToTime() {
    now="$(nowTime)"
    if (echo "$1" | grep "^-" > /dev/null); then
        then=$(date -d "$(echo $1|sed s/^-//)" '+%s')
        if [ "$then" ]; then
            if [ "$now" -lt "$then" ]; then
                echo $(expr "$then" '-' 3600 '*' 24)
            else
                echo $then
            fi
        fi
    else
        then=$(date -d "$1" '+%s')
        if [ "$then" ]; then
            if [ "$then" -lt "$now" ]; then
                echo $(expr "$then" '+' 3600 '*' 24)
            else
                echo $then
            fi
        fi
    fi
}

nowTime() {
    date '+%s'
}

dateSecs() {
    date -d "1970-01-01 UTC $1 seconds" "$2"
}

timeToFullDate() {
    dateSecs $1 '+%D klokken %R'
}

timeToDate() {
    thatday=$(dateSecs $1 '+%u')
    today=$(dateSecs $(nowTime) '+%u')
    if [ $1 -le "$(expr $(nowTime) - 3600 '*' 24 '*' 7 )" ]; then
        timeToFullDate $1
    elif [ $1 -ge "$(expr $(nowTime) + 3600 '*' 24 '*' 7 )" ]; then
        timeToFullDate $1
    elif [ "$thatday" = "$today" ]; then
        dateSecs $1 '+i dag klokken %R'
    elif [ "$thatday" = "$(expr $today - 1)" -o "(" "$today" = 1 -a "$thatday" = 7 ")" ]; then
        dateSecs $1 '+i går klokken %R'
    elif [ "$thatday" = "$(expr $today + 1)" -o "(" "$today" = 7 -a "$thatday" = 1 ")" ]; then
        dateSecs $1 '+i morgen klokken %R'
    else
        dateSecs $1 '+på %A klokken %R'
    fi
}

daysSince() {
    then=$(date +%s -d "$1")
    now=$(nowTime)
    if [ "$then" -gt "$(expr $now - 3600 '*' 24)" ]; then
        echo "under et døgn"
    elif [ "$then" -gt "$(expr $now - 3600 '*' 24 '*' 2)" ]; then
        echo "omkring et døgn"
    else
        echo "$(expr '(' $now - $then ')' / '(' 3600 '*' 24 ')') dage"
    fi
}

checkNextEggs() {
    time=$(nextEggs | head -n 1)
    if [ ! "$time" ]; then
        return 1
    else
        echo $time
    fi
}

extractDate() {
    while [ $# -ge 1 ]; do
        time=$(dateToTime $1)
        if [ "$time" ]; then
            echo $time
            return 0
        fi
        shift
    done
    checkNextEggs
}

extractUsername() {
    while [ $# -ge 1 ]; do
        name="$(randomName $1)"
        if [ "$name" ]; then
            echo $name
            return 0
        fi
        shift
    done
    randomName $EGGS_USER
}

updateSubTime() {
    aliases "$1" | while read -r alias; do
        dbDelete "users/$alias/eggsactly";
    done
    dbWriteArg "users/$1/eggsactly" "$2"
}

addToEggs() {
    if [ $# -eq 3 ]; then
        echo "$2, $3" >> $CONCIEGGS_DB_DIR/eggs/$1
    else
        echo "$2" >> $CONCIEGGS_DB_DIR/eggs/$1
    fi
    updateSubTime "$2" "$(nowTime)"
}

isInEggs() { # Cannot trust return value due to subshell.
    time=$1
    name="$2"
    if [ -s "$CONCIEGGS_DB_DIR/eggs/$time" ]; then
        aliases "$name" | while read alias; do
            if cat $CONCIEGGS_DB_DIR/eggs/$time | sed 's/,.*//' \
                | fgrep -x "$alias"; then
                return 0
            fi
        done
    fi
    return 1
}

rmFromEggs() {
    time=$1
    export TRAITOR="$2"
    tmpfile=$(mktemp)
    cat $CONCIEGGS_DB_DIR/eggs/$time \
        | awk -F, '$1!=ENVIRON["TRAITOR"]' > $tmpfile
    if [ -s $tmpfile ]; then
        mv $tmpfile $CONCIEGGS_DB_DIR/eggs/$time
    else
        rm $tmpfile $CONCIEGGS_DB_DIR/eggs/$time
    fi
    updateSubTime "$TRAITOR" 0
}

nextEggs() {
    export TIME="$(nowTime)"
    ls $CONCIEGGS_DB_DIR/eggs | awk '$1>=ENVIRON["TIME"]'
}

prevEggs() {
    export TIME="$(nowTime)"
    ls $CONCIEGGS_DB_DIR/eggs | awk '$1<ENVIRON["TIME"]'
}

listEggsers() {
    cat $CONCIEGGS_DB_DIR/eggs/$1 | while read who; do
        name=$(echo "$who" | sed 's/,.*//')
        fact=$(echo "$who" | grep "," | sed 's/.*, //')
        if [ "$fact" ]; then
            echo "$(randomName "$name")(*$fact)"
        else
            echo $(randomName "$name")
        fi
    done
}

countEggsers() {
    listEggsers $1 | wc -l | sed 's/ *//'
}

describeEggs() {
    listEggsers $1 | randomise | enumerate
}

formatEggs() {
    date=$(dateSecs $1 '+%Y-%m-%d')
    hourmin=$(dateSecs $1 '+%k:%M"')
    participants=$(listEggsers $1 | commasize)
    shift
    comment="$*"
    if [ -z $comment ]; then
        echo "$date, $participants # ($hourmin)"
    else
        echo "$date, $participants # ($hourmin) $comment"
    fi
}

gitRefresh() {
    cd /eggsml
    git pull > /dev/null
}

tryGitChange() {
    msg=$1
    shift
    name="$(randomName $EGGS_USER)"
    if ! [ "$name" ]; then
        name="$EGGS_USER"
    fi
    (git add "$@" && git commit -m "$name: $msg" && git push git@github.com:Athas/EggsML.git) > /dev/null
}

gitRepair() {
    (git reset HEAD "$@" && git checkout "$@") > /dev/null
}

debtors () {
    eggstool balances \
        | sort -g | head -n 5 | awk '$1 < 0 { print $0, -1*$1 "kr" }' \
        | cut -d' ' -f 2- | commasize
}

setTopic () {
    echo /t "$(dbRead topic)  --  Største skyldnere: $(debtors)."
}

authedName () {
    cd $CONCIEGGS_IRC_DIR
    rm -rf nickserv
    echo '/PRIVMSG nickserv :info '$1 > in
    for i in $(seq 1 5); do
        authed=$(awk '{ match($0, "account[^a-zA-Z0-9_]+([a-zA-Z0-9_]+)", a); if (a[1]) { print a[1] }}' < nickserv/out)
        if [ "$authed" ]; then
            echo $authed
            return
        fi
        unknown=$(awk '/is not registered/' < nickserv/out)
        if [ "$unknown" ]; then
            return
        fi
        sleep 1
    done
}

isTrusted() {
    auth="$(authedName "$1")"
    if [ "$auth" ]; then
        cat "$CONCIEGGS_DB_DIR/mestre" | decomment | fgrep -x "$auth"
    fi
}

broke() {
    echo "Kommandoen fejlede!  Prøv at spørge mig om 'udu'."
}

fakebroke() {
    echo "Arh... $EGGS_USER, noget gik galt, du må hellere prøve igen";
    echo "Hm, jeg ved sgu ikke lige, men den gik ikke... prøv igen, $EGGS_USER";
    echo "$EGGS_USER: Intern, nondeterministisk fejl.  Kør kommandoen igen.";
    echo "$EGGS_USER: Noget gik galt.  Kør kommandoen igen.";
    echo "Noget knækkede under kørsel af kommandoen, $EGGS_USER.  Det kan være det virker, hvis du prøver igen.";
    echo
}

commands() {
    ls $CONCIEGGS_DIR/cmds | while read -r cmd; do
        if [ -x "$cmddir/$cmd" ] && [ -f "$cmddir/$cmd" ]; then
            echo "$cmd"
        fi
    done
}

runcmd() {
    rawcmd=$1
    cmd="$(basename -- "$rawcmd")"
    cmddir=$CONCIEGGS_DIR/cmds
    shift
    if cmpNames "$EGGS_USER" "reenberg"; then
        ex=$(fakebroke | randomise | head -n 1)
        if [ "$ex" ]; then
            echo "$ex"
            exit
        fi
    fi
    if [ "$cmd" ] && [ "$EGGS_USER" != "$CONCIEGGS_NAME" ]; then
        if [ -x "$cmddir/$cmd" ] && [ -f "$cmddir/$cmd" ]; then
            "$cmddir/$cmd" "$@" || broke
        else
            othercmd="$(commands|levenshtein "$cmd"|sort -n|head -n 1|cut -d ' ' -f 2-)"
            if [ "$othercmd" ]; then
                echo "Jeg antager at du mente $othercmd!"
                "$cmddir/$othercmd" "$@" || broke
            else
                echo "$EGGS_USER: Du bad mig om $cmd, men den kommando har jeg ikke!"
                echo "Skriv 'concieggs: kommandoer' for at få en liste over mulige kommandoer."
            fi
        fi
    fi
}

lookupDebt() {
    who="$(aliases "$1")"
    # ja, vi beregner alles gæld, selv om vi kun er interesseret i et
    # enkelt af tallene
    eggstool balances | while read -r line; do
        name="$(echo "$line" | cut -d' ' -f 2)"
        if echo "$who" | fgrep -x "$name" > /dev/null; then
            echo "$line" | cut -d' ' -f 1 | awk '{ print -1*$0 }'
            return
        fi
    done
}

checkCatalogue() {
    needle="$1"
    dbIterate katalog | while read -r item; do
        dbRead "$item"
    done | sort | fgrep -i "$needle" | head -n 1
}

# Database layer

dbExists() {
    [ -e "$CONCIEGGS_DB_DIR/store/$1" ]
}

dbRead() {
    dbExists "$1" && cat "$CONCIEGGS_DB_DIR/store/$1"
}

dbWrite() {
    mkdir -p "$CONCIEGGS_DB_DIR/store/$(dirname "$1")"
    cat > "$CONCIEGGS_DB_DIR/store/$1"
}

dbNewNode() {
    mkdir -p "$CONCIEGGS_DB_DIR/store/$1"
}

dbWriteArg() {
    dest=$1
    shift
    echo "$@"| dbWrite "$dest"
}

dbDelete() {
    rm -rf "$CONCIEGGS_DB_DIR/store/$1"
    parent="$(dirname "$1")"
    if [ "$parent" != / -a "$parent" != . ]; then
        if ! [ "$(dbIterate $parent)" ]; then
            dbDelete "$parent"
        fi
    fi
}

dbIterate() {
    [ -d "$CONCIEGGS_DB_DIR/store/$1" ] \
        && ls "$CONCIEGGS_DB_DIR/store/$1" | while read -r child; do
        echo "$1/$child"
    done
}

dbGetFreeFilename() {
    parent=$1
    if [ -f "$CONCIEGGS_DB_DIR/store/$1" ] \
        || ! mkdir -p "$CONCIEGGS_DB_DIR/store/$parent"; then
        false
    else
        newfile="$(ls "$CONCIEGGS_DB_DIR/store/$parent" | \
            egrep '^[0-9]+$'|sort -n| \
            awk 'BEGIN { seen=-1 } { if ($0==seen+1) { seen++ } else { exit }} END { print seen+1 }')"
        echo "$parent/$newfile"
    fi
}

dbInsertNode() {
    node=$(dbGetFreeFilename "$1")
    dbNewNode "$node" && echo "$node"
}

dbInsertData() {
    node=$(dbGetFreeFilename "$1")
    dbWrite "$node" && echo "$node"
}

dbUserGet() {
    user="$1"
    node="$2"
    aliases "$1" | while read -r alias; do
        if dbExists "users/$alias/$node"; then
            echo "users/$alias/$node"
            return
        fi
    done
}

dbUserRead() {
    user="$1"
    node="$2"
    realnode="$(dbUserGet $1 $2)"
    if [ "$realnode" ]; then
        dbRead "$realnode"
    fi
}

dbUserWrite() {
    user="$1"
    node="$2"
    realnode="$(dbUserGet "$1" "$2")"
    if [ "$realnode" ]; then
        dbWrite "$realnode"
    else
        alias="$(randomName "$1")"
        dbWrite "users/$alias/$node"
    fi
}

dbUserDelete() {
    user="$1"
    node="$2"
    realnode="$(dbUserGet $1 $2)"
    if [ "$realnode" ]; then
        dbDelete "$realnode"
    fi
}
